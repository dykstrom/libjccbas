# GOSUB/RETURN Implementation in libjccbas

## Overview

This implementation provides C library functions for managing BASIC GOSUB/RETURN statements in LLVM IR code generated by the JCC compiler.

## Why Use C Functions?

Using C library functions to manage the GOSUB/RETURN stack offers several advantages:

1. **Cleaner LLVM IR**: Less boilerplate code in generated IR
2. **Better error handling**: C code can provide clear error messages for stack overflow/underflow
3. **Easier debugging**: Stack depth and state can be inspected via C functions
4. **Maintainability**: Stack implementation can be modified without changing compiler
5. **Thread safety**: Could be made thread-safe if needed (future enhancement)

## Implementation Details

### C Library Functions

The library provides four functions in `main/inc/gosub.h`:

```c
void gosub_push(void* addr);  // Push return address
void* gosub_pop(void);         // Pop return address
void gosub_init(void);         // Initialize (automatic)
int gosub_depth(void);         // Get stack depth
```

### Internal Stack

- Stack size: 100 entries (configurable in `gosub.c`)
- Automatic initialization on first use
- Error handling for overflow (GOSUB depth > 100)
- Error handling for underflow (RETURN without GOSUB)

### LLVM IR Integration

The JCC compiler generates:

**For GOSUB:**
```llvm
; Push return address using blockaddress
call void @gosub_push(ptr blockaddress(@main, %return_label))
; Jump to subroutine
br label %subroutine_label
```

**For RETURN:**
```llvm
; Pop return address
%return_addr = call ptr @gosub_pop()
; Jump back using indirectbr
indirectbr ptr %return_addr, [label %possible_return1, label %possible_return2, ...]
```

### Key LLVM Features Used

1. **blockaddress**: Gets a pointer to a basic block (label)
   - `blockaddress(@function, %label)` returns `ptr` (opaque pointer)
   - This is the "return address" stored on the stack

2. **indirectbr**: Indirect branch to an address
   - `indirectbr ptr %addr, [label %possible1, ...]`
   - Must list all possible target labels (compiler responsibility)

## Building and Testing

### Build the Library
```bash
make
```

This compiles `gosub.c` and links it into `libjccbas.dll` or `libjccbas.a`.

### Test the C Functions
```bash
./bin/clang/test_gosub  # or ./bin/gcc/test_gosub.exe on Windows
```

## Compiler Implementation Notes

When JCC generates LLVM IR for GOSUB/RETURN:

1. **Import library functions**: Declare `gosub_push` and `gosub_pop` at the top of each module
2. **Generate GOSUB**:
   - Call `gosub_push` with `blockaddress` of the next statement
   - Branch to the subroutine label
3. **Generate RETURN**:
   - Call `gosub_pop` to get return address
   - Use `indirectbr` with the address and list of all possible return targets
4. **Track return targets**: Compiler must maintain a list of all labels that could be returned to (every statement following a GOSUB)

## Limitations

- Maximum nesting depth: 100 levels (configurable)
- Not thread-safe in current implementation
- `indirectbr` requires listing all possible targets at compile time

## Future Enhancements

- Thread-local storage for thread safety
- Configurable stack size via initialization parameter
- Stack trace functionality for debugging
- Performance optimizations for deeply nested calls
